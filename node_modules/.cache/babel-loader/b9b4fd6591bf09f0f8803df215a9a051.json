{"ast":null,"code":"/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport * as tslib_1 from \"tslib\";\nimport { Constants, PersistentCacheKeys, TemporaryCacheKeys, ErrorCacheKeys } from \"../utils/Constants\";\nimport { AccessTokenCacheItem } from \"./AccessTokenCacheItem\";\nimport { BrowserStorage } from \"./BrowserStorage\";\nimport { ClientAuthError } from \"../error/ClientAuthError\";\n/**\n * @hidden\n */\n\nvar AuthCache =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(AuthCache, _super);\n\n  function AuthCache(clientId, cacheLocation, storeAuthStateInCookie) {\n    var _this = _super.call(this, cacheLocation) || this;\n\n    _this.clientId = clientId; // This is hardcoded to true for now. We may make this configurable in the future\n\n    _this.rollbackEnabled = true;\n\n    _this.migrateCacheEntries(storeAuthStateInCookie);\n\n    return _this;\n  }\n  /**\n   * Support roll back to old cache schema until the next major release: true by default now\n   * @param storeAuthStateInCookie\n   */\n\n\n  AuthCache.prototype.migrateCacheEntries = function (storeAuthStateInCookie) {\n    var _this = this;\n\n    var idTokenKey = Constants.cachePrefix + \".\" + PersistentCacheKeys.IDTOKEN;\n    var clientInfoKey = Constants.cachePrefix + \".\" + PersistentCacheKeys.CLIENT_INFO;\n    var errorKey = Constants.cachePrefix + \".\" + ErrorCacheKeys.ERROR;\n    var errorDescKey = Constants.cachePrefix + \".\" + ErrorCacheKeys.ERROR_DESC;\n\n    var idTokenValue = _super.prototype.getItem.call(this, idTokenKey);\n\n    var clientInfoValue = _super.prototype.getItem.call(this, clientInfoKey);\n\n    var errorValue = _super.prototype.getItem.call(this, errorKey);\n\n    var errorDescValue = _super.prototype.getItem.call(this, errorDescKey);\n\n    var values = [idTokenValue, clientInfoValue, errorValue, errorDescValue];\n    var keysToMigrate = [PersistentCacheKeys.IDTOKEN, PersistentCacheKeys.CLIENT_INFO, ErrorCacheKeys.ERROR, ErrorCacheKeys.ERROR_DESC];\n    keysToMigrate.forEach(function (cacheKey, index) {\n      return _this.duplicateCacheEntry(cacheKey, values[index], storeAuthStateInCookie);\n    });\n  };\n  /**\n   * Utility function to help with roll back keys\n   * @param newKey\n   * @param value\n   * @param storeAuthStateInCookie\n   */\n\n\n  AuthCache.prototype.duplicateCacheEntry = function (newKey, value, storeAuthStateInCookie) {\n    if (value) {\n      this.setItem(newKey, value, storeAuthStateInCookie);\n    }\n  };\n  /**\n   * Prepend msal.<client-id> to each key; Skip for any JSON object as Key (defined schemas do not need the key appended: AccessToken Keys or the upcoming schema)\n   * @param key\n   * @param addInstanceId\n   */\n\n\n  AuthCache.prototype.generateCacheKey = function (key, addInstanceId) {\n    try {\n      // Defined schemas do not need the key appended\n      JSON.parse(key);\n      return key;\n    } catch (e) {\n      if (key.indexOf(\"\" + Constants.cachePrefix) === 0 || key.indexOf(Constants.adalIdToken) === 0) {\n        return key;\n      }\n\n      return addInstanceId ? Constants.cachePrefix + \".\" + this.clientId + \".\" + key : Constants.cachePrefix + \".\" + key;\n    }\n  };\n  /**\n   * add value to storage\n   * @param key\n   * @param value\n   * @param enableCookieStorage\n   */\n\n\n  AuthCache.prototype.setItem = function (key, value, enableCookieStorage, state) {\n    _super.prototype.setItem.call(this, this.generateCacheKey(key, true), value, enableCookieStorage);\n\n    if (this.rollbackEnabled) {\n      _super.prototype.setItem.call(this, this.generateCacheKey(key, false), value, enableCookieStorage);\n    }\n  };\n  /**\n   * get one item by key from storage\n   * @param key\n   * @param enableCookieStorage\n   */\n\n\n  AuthCache.prototype.getItem = function (key, enableCookieStorage) {\n    return _super.prototype.getItem.call(this, this.generateCacheKey(key, true), enableCookieStorage);\n  };\n  /**\n   * remove value from storage\n   * @param key\n   */\n\n\n  AuthCache.prototype.removeItem = function (key) {\n    _super.prototype.removeItem.call(this, this.generateCacheKey(key, true));\n\n    if (this.rollbackEnabled) {\n      _super.prototype.removeItem.call(this, this.generateCacheKey(key, false));\n    }\n  };\n  /**\n   * Reset the cache items\n   */\n\n\n  AuthCache.prototype.resetCacheItems = function () {\n    var storage = window[this.cacheLocation];\n    var key;\n\n    for (key in storage) {\n      // Check if key contains msal prefix; For now, we are clearing all cache items created by MSAL.js\n      if (storage.hasOwnProperty(key) && key.indexOf(Constants.cachePrefix) !== -1) {\n        _super.prototype.removeItem.call(this, key); // TODO: Clear cache based on client id (clarify use cases where this is needed)\n\n      }\n    }\n  };\n  /**\n   * Reset all temporary cache items\n   */\n\n\n  AuthCache.prototype.resetTempCacheItems = function (state) {\n    var storage = window[this.cacheLocation];\n    var key; // check state and remove associated cache\n\n    for (key in storage) {\n      if (!state || key.indexOf(state) !== -1) {\n        var splitKey = key.split(Constants.resourceDelimiter);\n        var keyState = splitKey.length > 1 ? splitKey[splitKey.length - 1] : null;\n\n        if (keyState === state && !this.tokenRenewalInProgress(keyState)) {\n          this.removeItem(key);\n          this.setItemCookie(key, \"\", -1);\n          this.clearMsalCookie(state);\n        }\n      }\n    } // delete the interaction status cache\n\n\n    this.removeItem(TemporaryCacheKeys.INTERACTION_STATUS);\n    this.removeItem(TemporaryCacheKeys.REDIRECT_REQUEST);\n  };\n  /**\n   * Set cookies for IE\n   * @param cName\n   * @param cValue\n   * @param expires\n   */\n\n\n  AuthCache.prototype.setItemCookie = function (cName, cValue, expires) {\n    _super.prototype.setItemCookie.call(this, this.generateCacheKey(cName, true), cValue, expires);\n\n    if (this.rollbackEnabled) {\n      _super.prototype.setItemCookie.call(this, this.generateCacheKey(cName, false), cValue, expires);\n    }\n  };\n  /**\n   * get one item by key from cookies\n   * @param cName\n   */\n\n\n  AuthCache.prototype.getItemCookie = function (cName) {\n    return _super.prototype.getItemCookie.call(this, this.generateCacheKey(cName, true));\n  };\n  /**\n   * Get all access tokens in the cache\n   * @param clientId\n   * @param homeAccountIdentifier\n   */\n\n\n  AuthCache.prototype.getAllAccessTokens = function (clientId, homeAccountIdentifier) {\n    var _this = this;\n\n    var results = Object.keys(window[this.cacheLocation]).reduce(function (tokens, key) {\n      var keyMatches = key.match(clientId) && key.match(homeAccountIdentifier) && key.match(Constants.scopes);\n\n      if (keyMatches) {\n        var value = _this.getItem(key);\n\n        if (value) {\n          try {\n            var parseAtKey = JSON.parse(key);\n            var newAccessTokenCacheItem = new AccessTokenCacheItem(parseAtKey, JSON.parse(value));\n            return tokens.concat([newAccessTokenCacheItem]);\n          } catch (e) {\n            throw ClientAuthError.createCacheParseError(key);\n          }\n        }\n      }\n\n      return tokens;\n    }, []);\n    return results;\n  };\n  /**\n   * Return if the token renewal is still in progress\n   * @param stateValue\n   */\n\n\n  AuthCache.prototype.tokenRenewalInProgress = function (stateValue) {\n    var renewStatus = this.getItem(TemporaryCacheKeys.RENEW_STATUS + \"|\" + stateValue);\n    return !!(renewStatus && renewStatus === Constants.inProgress);\n  };\n  /**\n   * Clear all cookies\n   */\n\n\n  AuthCache.prototype.clearMsalCookie = function (state) {\n    this.clearItemCookie(TemporaryCacheKeys.NONCE_IDTOKEN + \"|\" + state);\n    this.clearItemCookie(TemporaryCacheKeys.STATE_LOGIN + \"|\" + state);\n    this.clearItemCookie(TemporaryCacheKeys.LOGIN_REQUEST + \"|\" + state);\n    this.clearItemCookie(TemporaryCacheKeys.STATE_ACQ_TOKEN + \"|\" + state);\n  };\n  /**\n   * Create acquireTokenAccountKey to cache account object\n   * @param accountId\n   * @param state\n   */\n\n\n  AuthCache.generateAcquireTokenAccountKey = function (accountId, state) {\n    return \"\" + TemporaryCacheKeys.ACQUIRE_TOKEN_ACCOUNT + Constants.resourceDelimiter + accountId + Constants.resourceDelimiter + state;\n  };\n  /**\n   * Create authorityKey to cache authority\n   * @param state\n   */\n\n\n  AuthCache.generateAuthorityKey = function (state) {\n    return \"\" + TemporaryCacheKeys.AUTHORITY + Constants.resourceDelimiter + state;\n  };\n\n  return AuthCache;\n}(BrowserStorage);\n\nexport { AuthCache };","map":{"version":3,"sources":["../../src/cache/AuthCache.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport * as tslib_1 from \"tslib\";\nimport { Constants, PersistentCacheKeys, TemporaryCacheKeys, ErrorCacheKeys } from \"../utils/Constants\";\nimport { AccessTokenCacheItem } from \"./AccessTokenCacheItem\";\nimport { BrowserStorage } from \"./BrowserStorage\";\nimport { ClientAuthError } from \"../error/ClientAuthError\";\n/**\n * @hidden\n */\nvar AuthCache = /** @class */ (function (_super) {\n    tslib_1.__extends(AuthCache, _super);\n    function AuthCache(clientId, cacheLocation, storeAuthStateInCookie) {\n        var _this = _super.call(this, cacheLocation) || this;\n        _this.clientId = clientId;\n        // This is hardcoded to true for now. We may make this configurable in the future\n        _this.rollbackEnabled = true;\n        _this.migrateCacheEntries(storeAuthStateInCookie);\n        return _this;\n    }\n    /**\n     * Support roll back to old cache schema until the next major release: true by default now\n     * @param storeAuthStateInCookie\n     */\n    AuthCache.prototype.migrateCacheEntries = function (storeAuthStateInCookie) {\n        var _this = this;\n        var idTokenKey = Constants.cachePrefix + \".\" + PersistentCacheKeys.IDTOKEN;\n        var clientInfoKey = Constants.cachePrefix + \".\" + PersistentCacheKeys.CLIENT_INFO;\n        var errorKey = Constants.cachePrefix + \".\" + ErrorCacheKeys.ERROR;\n        var errorDescKey = Constants.cachePrefix + \".\" + ErrorCacheKeys.ERROR_DESC;\n        var idTokenValue = _super.prototype.getItem.call(this, idTokenKey);\n        var clientInfoValue = _super.prototype.getItem.call(this, clientInfoKey);\n        var errorValue = _super.prototype.getItem.call(this, errorKey);\n        var errorDescValue = _super.prototype.getItem.call(this, errorDescKey);\n        var values = [idTokenValue, clientInfoValue, errorValue, errorDescValue];\n        var keysToMigrate = [PersistentCacheKeys.IDTOKEN, PersistentCacheKeys.CLIENT_INFO, ErrorCacheKeys.ERROR, ErrorCacheKeys.ERROR_DESC];\n        keysToMigrate.forEach(function (cacheKey, index) { return _this.duplicateCacheEntry(cacheKey, values[index], storeAuthStateInCookie); });\n    };\n    /**\n     * Utility function to help with roll back keys\n     * @param newKey\n     * @param value\n     * @param storeAuthStateInCookie\n     */\n    AuthCache.prototype.duplicateCacheEntry = function (newKey, value, storeAuthStateInCookie) {\n        if (value) {\n            this.setItem(newKey, value, storeAuthStateInCookie);\n        }\n    };\n    /**\n     * Prepend msal.<client-id> to each key; Skip for any JSON object as Key (defined schemas do not need the key appended: AccessToken Keys or the upcoming schema)\n     * @param key\n     * @param addInstanceId\n     */\n    AuthCache.prototype.generateCacheKey = function (key, addInstanceId) {\n        try {\n            // Defined schemas do not need the key appended\n            JSON.parse(key);\n            return key;\n        }\n        catch (e) {\n            if (key.indexOf(\"\" + Constants.cachePrefix) === 0 || key.indexOf(Constants.adalIdToken) === 0) {\n                return key;\n            }\n            return addInstanceId ? Constants.cachePrefix + \".\" + this.clientId + \".\" + key : Constants.cachePrefix + \".\" + key;\n        }\n    };\n    /**\n     * add value to storage\n     * @param key\n     * @param value\n     * @param enableCookieStorage\n     */\n    AuthCache.prototype.setItem = function (key, value, enableCookieStorage, state) {\n        _super.prototype.setItem.call(this, this.generateCacheKey(key, true), value, enableCookieStorage);\n        if (this.rollbackEnabled) {\n            _super.prototype.setItem.call(this, this.generateCacheKey(key, false), value, enableCookieStorage);\n        }\n    };\n    /**\n     * get one item by key from storage\n     * @param key\n     * @param enableCookieStorage\n     */\n    AuthCache.prototype.getItem = function (key, enableCookieStorage) {\n        return _super.prototype.getItem.call(this, this.generateCacheKey(key, true), enableCookieStorage);\n    };\n    /**\n     * remove value from storage\n     * @param key\n     */\n    AuthCache.prototype.removeItem = function (key) {\n        _super.prototype.removeItem.call(this, this.generateCacheKey(key, true));\n        if (this.rollbackEnabled) {\n            _super.prototype.removeItem.call(this, this.generateCacheKey(key, false));\n        }\n    };\n    /**\n     * Reset the cache items\n     */\n    AuthCache.prototype.resetCacheItems = function () {\n        var storage = window[this.cacheLocation];\n        var key;\n        for (key in storage) {\n            // Check if key contains msal prefix; For now, we are clearing all cache items created by MSAL.js\n            if (storage.hasOwnProperty(key) && (key.indexOf(Constants.cachePrefix) !== -1)) {\n                _super.prototype.removeItem.call(this, key);\n                // TODO: Clear cache based on client id (clarify use cases where this is needed)\n            }\n        }\n    };\n    /**\n     * Reset all temporary cache items\n     */\n    AuthCache.prototype.resetTempCacheItems = function (state) {\n        var storage = window[this.cacheLocation];\n        var key;\n        // check state and remove associated cache\n        for (key in storage) {\n            if (!state || key.indexOf(state) !== -1) {\n                var splitKey = key.split(Constants.resourceDelimiter);\n                var keyState = splitKey.length > 1 ? splitKey[splitKey.length - 1] : null;\n                if (keyState === state && !this.tokenRenewalInProgress(keyState)) {\n                    this.removeItem(key);\n                    this.setItemCookie(key, \"\", -1);\n                    this.clearMsalCookie(state);\n                }\n            }\n        }\n        // delete the interaction status cache\n        this.removeItem(TemporaryCacheKeys.INTERACTION_STATUS);\n        this.removeItem(TemporaryCacheKeys.REDIRECT_REQUEST);\n    };\n    /**\n     * Set cookies for IE\n     * @param cName\n     * @param cValue\n     * @param expires\n     */\n    AuthCache.prototype.setItemCookie = function (cName, cValue, expires) {\n        _super.prototype.setItemCookie.call(this, this.generateCacheKey(cName, true), cValue, expires);\n        if (this.rollbackEnabled) {\n            _super.prototype.setItemCookie.call(this, this.generateCacheKey(cName, false), cValue, expires);\n        }\n    };\n    /**\n     * get one item by key from cookies\n     * @param cName\n     */\n    AuthCache.prototype.getItemCookie = function (cName) {\n        return _super.prototype.getItemCookie.call(this, this.generateCacheKey(cName, true));\n    };\n    /**\n     * Get all access tokens in the cache\n     * @param clientId\n     * @param homeAccountIdentifier\n     */\n    AuthCache.prototype.getAllAccessTokens = function (clientId, homeAccountIdentifier) {\n        var _this = this;\n        var results = Object.keys(window[this.cacheLocation]).reduce(function (tokens, key) {\n            var keyMatches = key.match(clientId) && key.match(homeAccountIdentifier) && key.match(Constants.scopes);\n            if (keyMatches) {\n                var value = _this.getItem(key);\n                if (value) {\n                    try {\n                        var parseAtKey = JSON.parse(key);\n                        var newAccessTokenCacheItem = new AccessTokenCacheItem(parseAtKey, JSON.parse(value));\n                        return tokens.concat([newAccessTokenCacheItem]);\n                    }\n                    catch (e) {\n                        throw ClientAuthError.createCacheParseError(key);\n                    }\n                }\n            }\n            return tokens;\n        }, []);\n        return results;\n    };\n    /**\n     * Return if the token renewal is still in progress\n     * @param stateValue\n     */\n    AuthCache.prototype.tokenRenewalInProgress = function (stateValue) {\n        var renewStatus = this.getItem(TemporaryCacheKeys.RENEW_STATUS + \"|\" + stateValue);\n        return !!(renewStatus && renewStatus === Constants.inProgress);\n    };\n    /**\n     * Clear all cookies\n     */\n    AuthCache.prototype.clearMsalCookie = function (state) {\n        this.clearItemCookie(TemporaryCacheKeys.NONCE_IDTOKEN + \"|\" + state);\n        this.clearItemCookie(TemporaryCacheKeys.STATE_LOGIN + \"|\" + state);\n        this.clearItemCookie(TemporaryCacheKeys.LOGIN_REQUEST + \"|\" + state);\n        this.clearItemCookie(TemporaryCacheKeys.STATE_ACQ_TOKEN + \"|\" + state);\n    };\n    /**\n     * Create acquireTokenAccountKey to cache account object\n     * @param accountId\n     * @param state\n     */\n    AuthCache.generateAcquireTokenAccountKey = function (accountId, state) {\n        return \"\" + TemporaryCacheKeys.ACQUIRE_TOKEN_ACCOUNT + Constants.resourceDelimiter + accountId + Constants.resourceDelimiter + state;\n    };\n    /**\n     * Create authorityKey to cache authority\n     * @param state\n     */\n    AuthCache.generateAuthorityKey = function (state) {\n        return \"\" + TemporaryCacheKeys.AUTHORITY + Constants.resourceDelimiter + state;\n    };\n    return AuthCache;\n}(BrowserStorage));\nexport { AuthCache };\n//# sourceMappingURL=AuthCache.js.map"]},"metadata":{},"sourceType":"module"}