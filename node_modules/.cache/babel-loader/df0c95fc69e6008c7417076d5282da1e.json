{"ast":null,"code":"/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport * as tslib_1 from \"tslib\";\nimport { Constants, PromptState, BlacklistedEQParams } from \"../utils/Constants\";\nimport { ClientConfigurationError } from \"../error/ClientConfigurationError\";\nimport { ScopeSet } from \"../ScopeSet\";\nimport { StringUtils } from \"../utils/StringUtils\";\nimport { CryptoUtils } from \"../utils/CryptoUtils\";\n/**\n * @hidden\n */\n\nvar RequestUtils =\n/** @class */\nfunction () {\n  function RequestUtils() {}\n  /**\n   * @ignore\n   *\n   * @param request\n   * @param isLoginCall\n   * @param requestType\n   * @param redirectCallbacksSet\n   * @param cacheStorage\n   * @param clientId\n   *\n   * validates all request parameters and generates a consumable request object\n   */\n\n\n  RequestUtils.validateRequest = function (request, isLoginCall, clientId, requestType, redirectCallbacksSet) {\n    // Throw error if request is empty for acquire * calls\n    if (!isLoginCall && !request) {\n      throw ClientConfigurationError.createEmptyRequestError();\n    } // Throw error if callbacks are not set before redirect\n\n\n    if (requestType == Constants.interactionTypeRedirect && !redirectCallbacksSet) {\n      throw ClientConfigurationError.createRedirectCallbacksNotSetError();\n    }\n\n    var scopes;\n    var extraQueryParameters;\n\n    if (request) {\n      // if extraScopesToConsent is passed in loginCall, append them to the login request; Validate and filter scopes (the validate function will throw if validation fails)\n      scopes = isLoginCall ? ScopeSet.appendScopes(request.scopes, request.extraScopesToConsent) : request.scopes;\n      ScopeSet.validateInputScope(scopes, !isLoginCall, clientId); // validate prompt parameter\n\n      this.validatePromptParameter(request.prompt); // validate extraQueryParameters\n\n      extraQueryParameters = this.validateEQParameters(request.extraQueryParameters, request.claimsRequest); // validate claimsRequest\n\n      this.validateClaimsRequest(request.claimsRequest);\n    } // validate and generate state and correlationId\n\n\n    var state = this.validateAndGenerateState(request && request.state);\n    var correlationId = this.validateAndGenerateCorrelationId(request && request.correlationId);\n\n    var validatedRequest = tslib_1.__assign({}, request, {\n      extraQueryParameters: extraQueryParameters,\n      scopes: scopes,\n      state: state,\n      correlationId: correlationId\n    });\n\n    return validatedRequest;\n  };\n  /**\n   * @ignore\n   *\n   * Utility to test if valid prompt value is passed in the request\n   * @param request\n   */\n\n\n  RequestUtils.validatePromptParameter = function (prompt) {\n    if (prompt) {\n      if ([PromptState.LOGIN, PromptState.SELECT_ACCOUNT, PromptState.CONSENT, PromptState.NONE].indexOf(prompt) < 0) {\n        throw ClientConfigurationError.createInvalidPromptError(prompt);\n      }\n    }\n  };\n  /**\n   * @ignore\n   *\n   * Removes unnecessary or duplicate query parameters from extraQueryParameters\n   * @param request\n   */\n\n\n  RequestUtils.validateEQParameters = function (extraQueryParameters, claimsRequest) {\n    var eQParams = tslib_1.__assign({}, extraQueryParameters);\n\n    if (!eQParams) {\n      return null;\n    }\n\n    if (claimsRequest) {\n      // this.logger.warning(\"Removed duplicate claims from extraQueryParameters. Please use either the claimsRequest field OR pass as extraQueryParameter - not both.\");\n      delete eQParams[Constants.claims];\n    }\n\n    BlacklistedEQParams.forEach(function (param) {\n      if (eQParams[param]) {\n        // this.logger.warning(\"Removed duplicate \" + param + \" from extraQueryParameters. Please use the \" + param + \" field in request object.\");\n        delete eQParams[param];\n      }\n    });\n    return eQParams;\n  };\n  /**\n   * @ignore\n   *\n   * Validates the claims passed in request is a JSON\n   * TODO: More validation will be added when the server team tells us how they have actually implemented claims\n   * @param claimsRequest\n   */\n\n\n  RequestUtils.validateClaimsRequest = function (claimsRequest) {\n    if (!claimsRequest) {\n      return;\n    }\n\n    var claims;\n\n    try {\n      claims = JSON.parse(claimsRequest);\n    } catch (e) {\n      throw ClientConfigurationError.createClaimsRequestParsingError(e);\n    }\n  };\n  /**\n   * @ignore\n   *\n   * generate unique state per request\n   * @param request\n   */\n\n\n  RequestUtils.validateAndGenerateState = function (state) {\n    // append GUID to user set state  or set one for the user if null\n    return !StringUtils.isEmpty(state) ? CryptoUtils.createNewGuid() + \"|\" + state : CryptoUtils.createNewGuid();\n  };\n  /**\n   * @ignore\n   *\n   * validate correlationId and generate if not valid or not set by the user\n   * @param correlationId\n   */\n\n\n  RequestUtils.validateAndGenerateCorrelationId = function (correlationId) {\n    // validate user set correlationId or set one for the user if null\n    if (correlationId && !CryptoUtils.isGuid(correlationId)) {\n      throw ClientConfigurationError.createInvalidCorrelationIdError();\n    }\n\n    return CryptoUtils.isGuid(correlationId) ? correlationId : CryptoUtils.createNewGuid();\n  };\n\n  return RequestUtils;\n}();\n\nexport { RequestUtils };","map":{"version":3,"sources":["../../src/utils/RequestUtils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport * as tslib_1 from \"tslib\";\nimport { Constants, PromptState, BlacklistedEQParams } from \"../utils/Constants\";\nimport { ClientConfigurationError } from \"../error/ClientConfigurationError\";\nimport { ScopeSet } from \"../ScopeSet\";\nimport { StringUtils } from \"../utils/StringUtils\";\nimport { CryptoUtils } from \"../utils/CryptoUtils\";\n/**\n * @hidden\n */\nvar RequestUtils = /** @class */ (function () {\n    function RequestUtils() {\n    }\n    /**\n     * @ignore\n     *\n     * @param request\n     * @param isLoginCall\n     * @param requestType\n     * @param redirectCallbacksSet\n     * @param cacheStorage\n     * @param clientId\n     *\n     * validates all request parameters and generates a consumable request object\n     */\n    RequestUtils.validateRequest = function (request, isLoginCall, clientId, requestType, redirectCallbacksSet) {\n        // Throw error if request is empty for acquire * calls\n        if (!isLoginCall && !request) {\n            throw ClientConfigurationError.createEmptyRequestError();\n        }\n        // Throw error if callbacks are not set before redirect\n        if (requestType == Constants.interactionTypeRedirect && !redirectCallbacksSet) {\n            throw ClientConfigurationError.createRedirectCallbacksNotSetError();\n        }\n        var scopes;\n        var extraQueryParameters;\n        if (request) {\n            // if extraScopesToConsent is passed in loginCall, append them to the login request; Validate and filter scopes (the validate function will throw if validation fails)\n            scopes = isLoginCall ? ScopeSet.appendScopes(request.scopes, request.extraScopesToConsent) : request.scopes;\n            ScopeSet.validateInputScope(scopes, !isLoginCall, clientId);\n            // validate prompt parameter\n            this.validatePromptParameter(request.prompt);\n            // validate extraQueryParameters\n            extraQueryParameters = this.validateEQParameters(request.extraQueryParameters, request.claimsRequest);\n            // validate claimsRequest\n            this.validateClaimsRequest(request.claimsRequest);\n        }\n        // validate and generate state and correlationId\n        var state = this.validateAndGenerateState(request && request.state);\n        var correlationId = this.validateAndGenerateCorrelationId(request && request.correlationId);\n        var validatedRequest = tslib_1.__assign({}, request, { extraQueryParameters: extraQueryParameters,\n            scopes: scopes,\n            state: state,\n            correlationId: correlationId });\n        return validatedRequest;\n    };\n    /**\n     * @ignore\n     *\n     * Utility to test if valid prompt value is passed in the request\n     * @param request\n     */\n    RequestUtils.validatePromptParameter = function (prompt) {\n        if (prompt) {\n            if ([PromptState.LOGIN, PromptState.SELECT_ACCOUNT, PromptState.CONSENT, PromptState.NONE].indexOf(prompt) < 0) {\n                throw ClientConfigurationError.createInvalidPromptError(prompt);\n            }\n        }\n    };\n    /**\n     * @ignore\n     *\n     * Removes unnecessary or duplicate query parameters from extraQueryParameters\n     * @param request\n     */\n    RequestUtils.validateEQParameters = function (extraQueryParameters, claimsRequest) {\n        var eQParams = tslib_1.__assign({}, extraQueryParameters);\n        if (!eQParams) {\n            return null;\n        }\n        if (claimsRequest) {\n            // this.logger.warning(\"Removed duplicate claims from extraQueryParameters. Please use either the claimsRequest field OR pass as extraQueryParameter - not both.\");\n            delete eQParams[Constants.claims];\n        }\n        BlacklistedEQParams.forEach(function (param) {\n            if (eQParams[param]) {\n                // this.logger.warning(\"Removed duplicate \" + param + \" from extraQueryParameters. Please use the \" + param + \" field in request object.\");\n                delete eQParams[param];\n            }\n        });\n        return eQParams;\n    };\n    /**\n     * @ignore\n     *\n     * Validates the claims passed in request is a JSON\n     * TODO: More validation will be added when the server team tells us how they have actually implemented claims\n     * @param claimsRequest\n     */\n    RequestUtils.validateClaimsRequest = function (claimsRequest) {\n        if (!claimsRequest) {\n            return;\n        }\n        var claims;\n        try {\n            claims = JSON.parse(claimsRequest);\n        }\n        catch (e) {\n            throw ClientConfigurationError.createClaimsRequestParsingError(e);\n        }\n    };\n    /**\n     * @ignore\n     *\n     * generate unique state per request\n     * @param request\n     */\n    RequestUtils.validateAndGenerateState = function (state) {\n        // append GUID to user set state  or set one for the user if null\n        return !StringUtils.isEmpty(state) ? CryptoUtils.createNewGuid() + \"|\" + state : CryptoUtils.createNewGuid();\n    };\n    /**\n     * @ignore\n     *\n     * validate correlationId and generate if not valid or not set by the user\n     * @param correlationId\n     */\n    RequestUtils.validateAndGenerateCorrelationId = function (correlationId) {\n        // validate user set correlationId or set one for the user if null\n        if (correlationId && !CryptoUtils.isGuid(correlationId)) {\n            throw ClientConfigurationError.createInvalidCorrelationIdError();\n        }\n        return CryptoUtils.isGuid(correlationId) ? correlationId : CryptoUtils.createNewGuid();\n    };\n    return RequestUtils;\n}());\nexport { RequestUtils };\n//# sourceMappingURL=RequestUtils.js.map"]},"metadata":{},"sourceType":"module"}