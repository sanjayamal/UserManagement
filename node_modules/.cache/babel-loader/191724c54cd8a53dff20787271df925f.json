{"ast":null,"code":"import DefaultEvent from \"./DefaultEvent\"; // for use in cache events\n\nvar MSAL_CACHE_EVENT_VALUE_PREFIX = \"msal.token\";\nvar MSAL_CACHE_EVENT_NAME = \"msal.cache_event\";\n\nvar createEventKey = function (event) {\n  return event.telemetryCorrelationId + \"-\" + event.eventId + \"-\" + event.eventName;\n};\n\nvar TelemetryManager =\n/** @class */\nfunction () {\n  function TelemetryManager(config, telemetryEmitter) {\n    // correlation Id to list of events\n    this.completedEvents = {}; // event key to event\n\n    this.inProgressEvents = {}; // correlation id to map of eventname to count\n\n    this.eventCountByCorrelationId = {}; // Implement after API EVENT\n\n    this.onlySendFailureTelemetry = false; // TODO THROW if bad options\n\n    this.telemetryPlatform = config.platform;\n    this.clientId = config.clientId;\n    this.onlySendFailureTelemetry = config.onlySendFailureTelemetry;\n    /*\n     * TODO, when i get to wiring this through, think about what it means if\n     * a developer does not implement telem at all, we still instrument, but telemetryEmitter can be\n     * optional?\n     */\n\n    this.telemetryEmitter = telemetryEmitter;\n  }\n\n  TelemetryManager.prototype.startEvent = function (event) {\n    if (!this.telemetryEmitter) {\n      return;\n    }\n\n    var eventKey = createEventKey(event);\n    this.inProgressEvents[eventKey] = event;\n  };\n\n  TelemetryManager.prototype.stopEvent = function (event) {\n    var eventKey = createEventKey(event);\n\n    if (!this.telemetryEmitter || !this.inProgressEvents[eventKey]) {\n      return;\n    }\n\n    event.stop();\n    this.incrementEventCount(event);\n    var completedEvents = this.completedEvents[event.telemetryCorrelationId];\n    this.completedEvents[event.telemetryCorrelationId] = (completedEvents || []).concat([event]);\n    delete this.inProgressEvents[eventKey];\n  };\n\n  TelemetryManager.prototype.flush = function (correlationId) {\n    var _this = this; // If there is only unfinished events should this still return them?\n\n\n    if (!this.telemetryEmitter || !this.completedEvents[correlationId]) {\n      return;\n    }\n\n    var orphanedEvents = this.getOrphanedEvents(correlationId);\n    orphanedEvents.forEach(function (event) {\n      return _this.incrementEventCount(event);\n    });\n    var eventsToFlush = this.completedEvents[correlationId].concat(orphanedEvents);\n    delete this.completedEvents[correlationId];\n    var eventCountsToFlush = this.eventCountByCorrelationId[correlationId];\n    delete this.eventCountByCorrelationId[correlationId]; // TODO add funcitonality for onlyFlushFailures after implementing api event? ??\n\n    if (!eventsToFlush || !eventsToFlush.length) {\n      return;\n    }\n\n    var defaultEvent = new DefaultEvent(this.telemetryPlatform, correlationId, this.clientId, eventCountsToFlush);\n    var eventsWithDefaultEvent = eventsToFlush.concat([defaultEvent]);\n    this.telemetryEmitter(eventsWithDefaultEvent.map(function (e) {\n      return e.get();\n    }));\n  };\n\n  TelemetryManager.prototype.incrementEventCount = function (event) {\n    var _a;\n    /*\n     * TODO, name cache event different?\n     * if type is cache event, change name\n     */\n\n\n    var eventName = event.eventName;\n    var eventCount = this.eventCountByCorrelationId[event.telemetryCorrelationId];\n\n    if (!eventCount) {\n      this.eventCountByCorrelationId[event.telemetryCorrelationId] = (_a = {}, _a[eventName] = 1, _a);\n    } else {\n      eventCount[eventName] = eventCount[eventName] ? eventCount[eventName] + 1 : 1;\n    }\n  };\n\n  TelemetryManager.prototype.getOrphanedEvents = function (correlationId) {\n    var _this = this;\n\n    return Object.keys(this.inProgressEvents).reduce(function (memo, eventKey) {\n      if (eventKey.indexOf(correlationId) !== -1) {\n        var event_1 = _this.inProgressEvents[eventKey];\n        delete _this.inProgressEvents[eventKey];\n        return memo.concat([event_1]);\n      }\n\n      return memo;\n    }, []);\n  };\n\n  return TelemetryManager;\n}();\n\nexport default TelemetryManager;","map":{"version":3,"sources":["../../src/telemetry/TelemetryManager.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import DefaultEvent from \"./DefaultEvent\";\n// for use in cache events\nvar MSAL_CACHE_EVENT_VALUE_PREFIX = \"msal.token\";\nvar MSAL_CACHE_EVENT_NAME = \"msal.cache_event\";\nvar createEventKey = function (event) { return (event.telemetryCorrelationId + \"-\" + event.eventId + \"-\" + event.eventName); };\nvar TelemetryManager = /** @class */ (function () {\n    function TelemetryManager(config, telemetryEmitter) {\n        // correlation Id to list of events\n        this.completedEvents = {};\n        // event key to event\n        this.inProgressEvents = {};\n        // correlation id to map of eventname to count\n        this.eventCountByCorrelationId = {};\n        // Implement after API EVENT\n        this.onlySendFailureTelemetry = false;\n        // TODO THROW if bad options\n        this.telemetryPlatform = config.platform;\n        this.clientId = config.clientId;\n        this.onlySendFailureTelemetry = config.onlySendFailureTelemetry;\n        /*\n         * TODO, when i get to wiring this through, think about what it means if\n         * a developer does not implement telem at all, we still instrument, but telemetryEmitter can be\n         * optional?\n         */\n        this.telemetryEmitter = telemetryEmitter;\n    }\n    TelemetryManager.prototype.startEvent = function (event) {\n        if (!this.telemetryEmitter) {\n            return;\n        }\n        var eventKey = createEventKey(event);\n        this.inProgressEvents[eventKey] = event;\n    };\n    TelemetryManager.prototype.stopEvent = function (event) {\n        var eventKey = createEventKey(event);\n        if (!this.telemetryEmitter || !this.inProgressEvents[eventKey]) {\n            return;\n        }\n        event.stop();\n        this.incrementEventCount(event);\n        var completedEvents = this.completedEvents[event.telemetryCorrelationId];\n        this.completedEvents[event.telemetryCorrelationId] = (completedEvents || []).concat([event]);\n        delete this.inProgressEvents[eventKey];\n    };\n    TelemetryManager.prototype.flush = function (correlationId) {\n        var _this = this;\n        // If there is only unfinished events should this still return them?\n        if (!this.telemetryEmitter || !this.completedEvents[correlationId]) {\n            return;\n        }\n        var orphanedEvents = this.getOrphanedEvents(correlationId);\n        orphanedEvents.forEach(function (event) { return _this.incrementEventCount(event); });\n        var eventsToFlush = this.completedEvents[correlationId].concat(orphanedEvents);\n        delete this.completedEvents[correlationId];\n        var eventCountsToFlush = this.eventCountByCorrelationId[correlationId];\n        delete this.eventCountByCorrelationId[correlationId];\n        // TODO add funcitonality for onlyFlushFailures after implementing api event? ??\n        if (!eventsToFlush || !eventsToFlush.length) {\n            return;\n        }\n        var defaultEvent = new DefaultEvent(this.telemetryPlatform, correlationId, this.clientId, eventCountsToFlush);\n        var eventsWithDefaultEvent = eventsToFlush.concat([defaultEvent]);\n        this.telemetryEmitter(eventsWithDefaultEvent.map(function (e) { return e.get(); }));\n    };\n    TelemetryManager.prototype.incrementEventCount = function (event) {\n        var _a;\n        /*\n         * TODO, name cache event different?\n         * if type is cache event, change name\n         */\n        var eventName = event.eventName;\n        var eventCount = this.eventCountByCorrelationId[event.telemetryCorrelationId];\n        if (!eventCount) {\n            this.eventCountByCorrelationId[event.telemetryCorrelationId] = (_a = {},\n                _a[eventName] = 1,\n                _a);\n        }\n        else {\n            eventCount[eventName] = eventCount[eventName] ? eventCount[eventName] + 1 : 1;\n        }\n    };\n    TelemetryManager.prototype.getOrphanedEvents = function (correlationId) {\n        var _this = this;\n        return Object.keys(this.inProgressEvents)\n            .reduce(function (memo, eventKey) {\n            if (eventKey.indexOf(correlationId) !== -1) {\n                var event_1 = _this.inProgressEvents[eventKey];\n                delete _this.inProgressEvents[eventKey];\n                return memo.concat([event_1]);\n            }\n            return memo;\n        }, []);\n    };\n    return TelemetryManager;\n}());\nexport default TelemetryManager;\n//# sourceMappingURL=TelemetryManager.js.map"]},"metadata":{},"sourceType":"module"}