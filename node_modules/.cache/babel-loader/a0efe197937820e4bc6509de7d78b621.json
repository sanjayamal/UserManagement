{"ast":null,"code":"/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * @hidden\n */\nimport { AadAuthority } from \"./AadAuthority\";\nimport { B2cAuthority } from \"./B2cAuthority\";\nimport { AuthorityType } from \"./Authority\";\nimport { ClientConfigurationErrorMessage } from \"../error/ClientConfigurationError\";\nimport { UrlUtils } from \"../utils/UrlUtils\";\nimport { StringUtils } from \"../utils/StringUtils\";\n\nvar AuthorityFactory =\n/** @class */\nfunction () {\n  function AuthorityFactory() {}\n  /**\n   * Parse the url and determine the type of authority\n   */\n\n\n  AuthorityFactory.DetectAuthorityFromUrl = function (authorityUrl) {\n    authorityUrl = UrlUtils.CanonicalizeUri(authorityUrl);\n    var components = UrlUtils.GetUrlComponents(authorityUrl);\n    var pathSegments = components.PathSegments;\n\n    switch (pathSegments[0]) {\n      case \"tfp\":\n        return AuthorityType.B2C;\n\n      default:\n        return AuthorityType.Aad;\n    }\n  };\n  /**\n   * Create an authority object of the correct type based on the url\n   * Performs basic authority validation - checks to see if the authority is of a valid type (eg aad, b2c)\n   */\n\n\n  AuthorityFactory.CreateInstance = function (authorityUrl, validateAuthority) {\n    if (StringUtils.isEmpty(authorityUrl)) {\n      return null;\n    }\n\n    var type = AuthorityFactory.DetectAuthorityFromUrl(authorityUrl); // Depending on above detection, create the right type.\n\n    switch (type) {\n      case AuthorityType.B2C:\n        return new B2cAuthority(authorityUrl, validateAuthority);\n\n      case AuthorityType.Aad:\n        return new AadAuthority(authorityUrl, validateAuthority);\n\n      default:\n        throw ClientConfigurationErrorMessage.invalidAuthorityType;\n    }\n  };\n\n  return AuthorityFactory;\n}();\n\nexport { AuthorityFactory };","map":{"version":3,"sources":["../../src/authority/AuthorityFactory.ts"],"names":[],"mappings":"AAAA;;;;;AAKA;;;AAGA,SAAS,YAAT,QAA6B,gBAA7B;AACA,SAAS,YAAT,QAA6B,gBAA7B;AACA,SAAoB,aAApB,QAAyC,aAAzC;AACA,SAAS,+BAAT,QAAgD,mCAAhD;AACA,SAAS,QAAT,QAAyB,mBAAzB;AACA,SAAS,WAAT,QAA4B,sBAA5B;;AAEA,IAAA,gBAAA;AAAA;AAAA,YAAA;AAAA,WAAA,gBAAA,GAAA,CAoCC;AAnCG;;;;;AAGe,EAAA,gBAAA,CAAA,sBAAA,GAAf,UAAsC,YAAtC,EAA0D;AACtD,IAAA,YAAY,GAAG,QAAQ,CAAC,eAAT,CAAyB,YAAzB,CAAf;AACA,QAAM,UAAU,GAAG,QAAQ,CAAC,gBAAT,CAA0B,YAA1B,CAAnB;AACA,QAAM,YAAY,GAAG,UAAU,CAAC,YAAhC;;AACA,YAAQ,YAAY,CAAC,CAAD,CAApB;AACI,WAAK,KAAL;AACI,eAAO,aAAa,CAAC,GAArB;;AACJ;AACI,eAAO,aAAa,CAAC,GAArB;AAJR;AAMH,GAVc;AAYf;;;;;;AAIc,EAAA,gBAAA,CAAA,cAAA,GAAd,UAA6B,YAA7B,EAAmD,iBAAnD,EAA6E;AACzE,QAAI,WAAW,CAAC,OAAZ,CAAoB,YAApB,CAAJ,EAAuC;AACnC,aAAO,IAAP;AACH;;AACD,QAAM,IAAI,GAAG,gBAAgB,CAAC,sBAAjB,CAAwC,YAAxC,CAAb,CAJyE,CAKzE;;AACA,YAAQ,IAAR;AACI,WAAK,aAAa,CAAC,GAAnB;AACI,eAAO,IAAI,YAAJ,CAAiB,YAAjB,EAA+B,iBAA/B,CAAP;;AACJ,WAAK,aAAa,CAAC,GAAnB;AACI,eAAO,IAAI,YAAJ,CAAiB,YAAjB,EAA+B,iBAA/B,CAAP;;AACJ;AACI,cAAM,+BAA+B,CAAC,oBAAtC;AANR;AAQH,GAda;;AAgBlB,SAAA,gBAAA;AAAC,CApCD,EAAA","sourceRoot":"","sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * @hidden\n */\nimport { AadAuthority } from \"./AadAuthority\";\nimport { B2cAuthority } from \"./B2cAuthority\";\nimport { AuthorityType } from \"./Authority\";\nimport { ClientConfigurationErrorMessage } from \"../error/ClientConfigurationError\";\nimport { UrlUtils } from \"../utils/UrlUtils\";\nimport { StringUtils } from \"../utils/StringUtils\";\nvar AuthorityFactory = /** @class */ (function () {\n    function AuthorityFactory() {\n    }\n    /**\n     * Parse the url and determine the type of authority\n     */\n    AuthorityFactory.DetectAuthorityFromUrl = function (authorityUrl) {\n        authorityUrl = UrlUtils.CanonicalizeUri(authorityUrl);\n        var components = UrlUtils.GetUrlComponents(authorityUrl);\n        var pathSegments = components.PathSegments;\n        switch (pathSegments[0]) {\n            case \"tfp\":\n                return AuthorityType.B2C;\n            default:\n                return AuthorityType.Aad;\n        }\n    };\n    /**\n     * Create an authority object of the correct type based on the url\n     * Performs basic authority validation - checks to see if the authority is of a valid type (eg aad, b2c)\n     */\n    AuthorityFactory.CreateInstance = function (authorityUrl, validateAuthority) {\n        if (StringUtils.isEmpty(authorityUrl)) {\n            return null;\n        }\n        var type = AuthorityFactory.DetectAuthorityFromUrl(authorityUrl);\n        // Depending on above detection, create the right type.\n        switch (type) {\n            case AuthorityType.B2C:\n                return new B2cAuthority(authorityUrl, validateAuthority);\n            case AuthorityType.Aad:\n                return new AadAuthority(authorityUrl, validateAuthority);\n            default:\n                throw ClientConfigurationErrorMessage.invalidAuthorityType;\n        }\n    };\n    return AuthorityFactory;\n}());\nexport { AuthorityFactory };\n//# sourceMappingURL=AuthorityFactory.js.map"]},"metadata":{},"sourceType":"module"}